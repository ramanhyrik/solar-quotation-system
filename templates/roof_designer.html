<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manual Roof Designer - Solar Panel Layout Calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        :root {
            --primary-blue: #00358A;
            --primary-dark: #002060;
            --success-green: #10B981;
            --text-dark: #1F2937;
            --text-medium: #6B7280;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #F9FAFB;
            color: var(--text-dark);
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 24px 40px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .container {
            max-width: 1400px;
            margin: 30px auto;
            padding: 0 20px;
        }

        .step-container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            display: none;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

        .step-container.active {
            display: block;
            animation: fadeSlideIn 0.4s ease-out forwards;
        }

        @keyframes fadeSlideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .upload-zone {
            border: 3px dashed var(--primary-blue);
            border-radius: 8px;
            padding: 60px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-zone:hover {
            background: #f8f9ff;
            border-color: var(--primary-dark);
        }

        .canvas-wrapper {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .canvas-container {
            flex: 1;
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .tools-panel {
            width: 300px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
        }

        .tool-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tool-btn:hover {
            background: #f0f0f0;
            border-color: var(--primary-blue);
        }

        .tool-btn.active {
            background: var(--primary-blue);
            color: white;
            border-color: var(--primary-blue);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            transform: translateY(0);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: var(--primary-blue);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-success {
            background: var(--success-green);
            color: white;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-dark);
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
        }

        .info-box {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid var(--primary-blue);
        }

        .results-panel {
            background: linear-gradient(135deg, var(--success-green) 0%, #059669 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .result-item {
            text-align: center;
        }

        .result-label {
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .result-value {
            font-size: 24px;
            font-weight: 700;
        }

        .instruction-badge {
            background: #FFC107;
            color: #000;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            display: inline-block;
            margin-bottom: 15px;
        }

        .tool-btn i,
        .btn i {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            flex-shrink: 0;
        }

        /* Modal System */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
            animation: fadeIn 0.2s ease-out;
        }

        .modal-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            animation: slideUp 0.3s ease-out;
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .modal-header h3 {
            flex: 1;
            margin: 0;
            font-size: 18px;
            color: var(--text-dark);
        }

        .modal-header i {
            width: 24px;
            height: 24px;
        }

        .modal-close {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: #f3f4f6;
        }

        .modal-close i {
            width: 20px;
            height: 20px;
            margin: 0;
        }

        .modal-body {
            padding: 24px;
            color: var(--text-medium);
            line-height: 1.6;
        }

        .modal-body p {
            margin: 0;
        }

        .modal-footer {
            padding: 16px 24px;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Loading Overlay */
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            z-index: 9999;
            align-items: center;
            justify-content: center;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-spinner {
            text-align: center;
            color: white;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-spinner p {
            font-size: 16px;
            font-weight: 500;
        }

        /* Tooltips */
        [data-tooltip] {
            position: relative;
            cursor: help;
        }

        [data-tooltip]::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            background: #1F2937;
            color: white;
            font-size: 13px;
            white-space: nowrap;
            border-radius: 6px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
        }

        [data-tooltip]::after {
            content: '';
            position: absolute;
            bottom: calc(100% + 2px);
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #1F2937;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        [data-tooltip]:hover::before,
        [data-tooltip]:hover::after {
            opacity: 1;
        }

        /* For form inputs, show tooltip on the label */
        .form-group label[data-tooltip] {
            cursor: help;
        }

        /* Keyboard shortcut styling */
        kbd {
            background: linear-gradient(to bottom, #f9f9f9, #e9e9e9);
            border: 1px solid #aaa;
            border-radius: 4px;
            box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset;
            color: #333;
            display: inline-block;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: 600;
            line-height: 1;
            padding: 4px 8px;
            white-space: nowrap;
        }

        .shortcuts-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .shortcuts-table th {
            background: #f3f4f6;
            padding: 10px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #e5e7eb;
        }

        .shortcuts-table td {
            padding: 10px;
            border-bottom: 1px solid #e5e7eb;
        }

        .shortcuts-table tr:last-child td {
            border-bottom: none;
        }

        .shortcuts-category {
            background: var(--primary-blue);
            color: white;
            padding: 8px 12px;
            margin: 15px 0 10px 0;
            border-radius: 4px;
            font-weight: 600;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <div>
                <h1>Manual Roof Designer</h1>
                <p style="margin-top: 5px; opacity: 0.9;">Draw Your Roof, Place Perfect Panels</p>
            </div>
            <div style="text-align: right; font-size: 14px;">
                <div>Welcome, {{ user.name }}!</div>
                <div><a href="/dashboard" style="color: #D9FF0D; text-decoration: none;">Back to Dashboard</a></div>
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Step 1: Upload Image -->
        <div id="step1" class="step-container active">
            <h2 style="margin-bottom: 20px;">Step 1: Upload Roof Image</h2>

            <div class="info-box">
                <strong>Manual Drawing Workflow</strong>
                <p style="margin: 5px 0 0 0; font-size: 14px; color: #666;">
                    Upload a clear, top-down image of the roof. You'll draw the roof boundary manually for complete control.
                    Best results with drone photos or satellite imagery from Google Maps.
                </p>
            </div>

            <!-- Customer Info -->
            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="margin-bottom: 15px; font-size: 16px;">Customer Information (Optional)</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div class="form-group">
                        <label>Customer Name:</label>
                        <input type="text" id="customerName" placeholder="Enter customer name">
                    </div>
                    <div class="form-group">
                        <label>Address:</label>
                        <input type="text" id="customerAddress" placeholder="Enter roof location">
                    </div>
                </div>
            </div>

            <div class="upload-zone" id="uploadZone">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" style="width: 60px; height: 60px; margin: 0 auto 20px;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
                <h3>Click to upload or drag & drop</h3>
                <p style="color: #666; margin-top: 10px;">JPG, PNG, or JPEG (Max 10MB)</p>
                <input type="file" id="imageInput" accept="image/*" style="display: none;">
            </div>

            <div id="uploadedImagePreview" style="display: none; margin-top: 20px;">
                <h3>Uploading...</h3>
                <p style="color: #666; margin-top: 10px;">Please wait while we prepare your workspace.</p>
            </div>
        </div>

        <!-- Step 2: Draw Roof & Exclusions -->
        <div id="step2" class="step-container">
            <h2 style="margin-bottom: 20px;">Step 2: Draw Roof Boundary & Exclusion Zones</h2>

            <div class="instruction-badge" id="drawingInstruction">
                Click on the image to draw roof boundary points. Click "Close Polygon" when done.
            </div>

            <div class="canvas-wrapper">
                <div class="canvas-container">
                    <canvas id="roofCanvas" width="900" height="700"></canvas>
                </div>

                <div class="tools-panel">
                    <div style="margin-bottom: 25px;">
                        <h3 style="font-size: 16px; margin-bottom: 15px; color: var(--text-dark); padding-bottom: 10px; border-bottom: 2px solid var(--primary-blue);">Edit Tools</h3>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                            <button class="tool-btn" id="undoBtn" onclick="undo()" disabled
                                    data-tooltip="Undo last action (Ctrl+Z)">
                                <i data-lucide="undo"></i>
                                <span>Undo</span>
                            </button>
                            <button class="tool-btn" id="redoBtn" onclick="redo()" disabled
                                    data-tooltip="Redo action (Ctrl+Y)">
                                <i data-lucide="redo"></i>
                                <span>Redo</span>
                            </button>
                        </div>
                    </div>

                    <div style="margin-bottom: 25px;">
                        <h3 style="font-size: 16px; margin-bottom: 15px; color: var(--text-dark); padding-bottom: 10px; border-bottom: 2px solid var(--primary-blue);">View Controls</h3>

                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                            <button class="tool-btn" onclick="zoomIn()" data-tooltip="Zoom in (Ctrl + Scroll up)">
                                <i data-lucide="zoom-in"></i>
                            </button>
                            <button class="tool-btn" onclick="zoomOut()" data-tooltip="Zoom out (Ctrl + Scroll down)">
                                <i data-lucide="zoom-out"></i>
                            </button>
                            <button class="tool-btn" onclick="resetZoom()" data-tooltip="Reset view (Ctrl+0)">
                                <i data-lucide="maximize"></i>
                            </button>
                        </div>
                        <div style="text-align: center; font-size: 13px; color: var(--text-medium); margin-bottom: 10px;">
                            Zoom: <span id="zoomLevel" style="font-weight: 600; color: var(--text-dark);">100%</span>
                        </div>
                        <div style="background: #e8f4fd; padding: 10px; border-radius: 6px; font-size: 12px; color: #1F2937;">
                            <strong>Tip:</strong> Hold <kbd style="background: white; padding: 2px 6px; border-radius: 3px; border: 1px solid #ddd;">Space</kbd> + drag to pan
                        </div>
                    </div>

                    <div style="margin-bottom: 25px;">
                        <h3 style="font-size: 16px; margin-bottom: 15px; color: var(--text-dark); padding-bottom: 10px; border-bottom: 2px solid var(--primary-blue);">Drawing Tools</h3>

                        <button class="tool-btn active" id="drawRoofBtn" onclick="startDrawingRoof()"
                                data-tooltip="Click points on the image to define the roof boundary">
                            <i data-lucide="home"></i>
                            <span>Draw Roof Boundary</span>
                        </button>
                        <button class="tool-btn" id="drawExclusionBtn" onclick="startDrawingExclusion()"
                                data-tooltip="Draw areas where panels cannot be placed (chimneys, vents, etc.)">
                            <i data-lucide="octagon-x"></i>
                            <span>Add Exclusion Polygon</span>
                        </button>
                        <button class="tool-btn" onclick="closePolygon()"
                                data-tooltip="Complete the current polygon shape">
                            <i data-lucide="check-circle"></i>
                            <span>Close Polygon</span>
                        </button>
                        <button class="tool-btn" id="editModeBtn" onclick="toggleEditMode()"
                                data-tooltip="Edit polygon points by dragging vertices">
                            <i data-lucide="edit-3"></i>
                            <span>Edit Points</span>
                        </button>
                        <button class="tool-btn" onclick="deleteSelected()"
                                data-tooltip="Delete the selected polygon (click polygon first, then delete)">
                            <i data-lucide="trash-2"></i>
                            <span>Delete Selected</span>
                        </button>
                        <button class="tool-btn" onclick="clearAll()"
                                data-tooltip="Remove all polygons and start over">
                            <i data-lucide="rotate-ccw"></i>
                            <span>Clear All</span>
                        </button>
                        <button class="tool-btn" onclick="showKeyboardShortcuts()"
                                data-tooltip="View all keyboard shortcuts">
                            <i data-lucide="keyboard"></i>
                            <span>Shortcuts</span>
                        </button>
                    </div>

                    <div style="margin-bottom: 25px;">
                        <h3 style="font-size: 16px; margin-bottom: 15px; color: var(--text-dark); padding-bottom: 10px; border-bottom: 2px solid var(--primary-blue);">Scale Calibration</h3>
                        <div class="form-group">
                            <label data-tooltip="Adjust based on your satellite image scale">Pixels per Meter:</label>
                            <input type="number" id="pixelsPerMeter" value="100" min="10" max="1000" step="10">
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Adjust if panels appear too large/small
                            </small>
                        </div>
                    </div>

                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button class="btn btn-primary" onclick="proceedToLayout()" style="width: 100%;">
                            Continue to Panel Layout
                        </button>
                        <button class="btn" style="background: #6B7280; color: white; width: 100%;" onclick="goToStep(1)">
                            Back
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 3: Panel Configuration -->
        <div id="step3" class="step-container">
            <h2 style="margin-bottom: 20px;">Step 3: Configure Solar Panel Layout</h2>

            <div class="canvas-wrapper">
                <div class="canvas-container">
                    <canvas id="layoutCanvas" width="900" height="700"></canvas>
                </div>

                <div class="tools-panel">
                    <div style="margin-bottom: 20px;">
                        <h3 style="font-size: 16px; margin-bottom: 15px;">Panel Specifications</h3>

                        <div class="form-group">
                            <label data-tooltip="Realistic range: 0.8m - 2.5m. Standard is 1.6m - 2.0m">Panel Width (m):</label>
                            <input type="number" id="panelWidth" value="1.7" min="0.8" max="2.5" step="0.1">
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Range: 0.8m - 2.5m
                            </small>
                        </div>

                        <div class="form-group">
                            <label data-tooltip="Realistic range: 0.8m - 2.0m. Standard is 0.9m - 1.2m">Panel Height (m):</label>
                            <input type="number" id="panelHeight" value="1.0" min="0.8" max="2.0" step="0.1">
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Range: 0.8m - 2.0m
                            </small>
                        </div>

                        <div class="form-group">
                            <label data-tooltip="Typical range: 300W - 450W per panel">Panel Power (W):</label>
                            <input type="number" id="panelPower" value="400" min="100" max="1000" step="50">
                        </div>

                        <div class="form-group">
                            <label data-tooltip="Auto tries both orientations for optimal coverage">Orientation:</label>
                            <select id="orientation">
                                <option value="auto" selected>Auto (Optimal Mix)</option>
                                <option value="landscape">Landscape Only</option>
                                <option value="portrait">Portrait Only</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label data-tooltip="Gap between panels for installation clearance">Spacing (cm):</label>
                            <input type="number" id="spacing" value="5" min="0" max="20" step="1">
                        </div>

                        <button class="btn btn-primary" style="width: 100%; margin-top: 15px;" onclick="calculatePanelLayout()">
                            Calculate Panel Layout
                        </button>
                    </div>

                    <div id="layoutResults" style="display: none;">
                        <div class="results-panel">
                            <h3 style="margin-bottom: 10px;">Layout Results</h3>
                            <div class="results-grid">
                                <div class="result-item">
                                    <div class="result-label">Panels</div>
                                    <div class="result-value" id="resultPanels">0</div>
                                </div>
                                <div class="result-item">
                                    <div class="result-label">Power</div>
                                    <div class="result-value" id="resultPower">0 kW</div>
                                </div>
                                <div class="result-item">
                                    <div class="result-label">Coverage</div>
                                    <div class="result-value" id="resultCoverage">0%</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 15px;">
                        <button class="btn btn-success" onclick="saveDesign()" id="saveBtn" style="width: 100%;" disabled>
                            Save Design
                        </button>
                        <button class="btn" style="background: #6B7280; color: white; width: 100%;" onclick="goToStep(2)">
                            Back to Drawing
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 4: Complete -->
        <div id="step4" class="step-container">
            <div style="background: #d1fae5; padding: 20px; border-radius: 8px; border-left: 4px solid var(--success-green); margin-bottom: 20px;">
                <h3 style="color: var(--success-green);">Roof Design Completed!</h3>
                <p style="margin-top: 10px; color: #065f46;">Your roof panel layout has been saved successfully.</p>
            </div>

            <div class="results-panel">
                <h3>Final Design Summary</h3>
                <div class="results-grid">
                    <div class="result-item">
                        <div class="result-label">Total Panels</div>
                        <div class="result-value" id="finalPanels">0</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">System Power</div>
                        <div class="result-value" id="finalPower">0 kW</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Coverage</div>
                        <div class="result-value" id="finalCoverage">0%</div>
                    </div>
                    <div class="result-item">
                        <div class="result-label">Roof Area</div>
                        <div class="result-value" id="finalArea">0 mÂ²</div>
                    </div>
                </div>
            </div>

            <div style="display: flex; gap: 15px; margin-top: 20px;">
                <button class="btn btn-primary" onclick="window.location.href='/dashboard'">Back to Dashboard</button>
                <button class="btn btn-success" onclick="startNewDesign()">Create New Design</button>
            </div>
        </div>
    </div>

    <!-- Custom Modal System -->
    <div id="modalOverlay" class="modal-overlay">
        <div class="modal-container">
            <div class="modal-header">
                <i data-lucide="alert-circle" id="modalIcon"></i>
                <h3 id="modalTitle">Alert</h3>
                <button class="modal-close" onclick="closeModal()">
                    <i data-lucide="x"></i>
                </button>
            </div>
            <div class="modal-body">
                <p id="modalMessage"></p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="closeModal()" id="modalOkBtn">OK</button>
                <button class="btn" style="background: #6B7280; color: white; display: none;"
                        onclick="closeModal(false)" id="modalCancelBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner">
            <div class="spinner"></div>
            <p id="loadingMessage">Processing...</p>
        </div>
    </div>

    <script>
        // Global variables
        let currentStep = 1;
        let canvas = null;
        let layoutCanvas = null;
        let designId = null;
        let uploadedImage = null;
        let roofPolygonPoints = [];
        let exclusionZones = []; // Array of {points: [{x, y}, ...], polygon: fabric.Polygon}
        let currentExclusionPoints = []; // Points for exclusion polygon being drawn
        let roofPolygonObject = null;
        let drawingMode = null; // 'roof' or 'exclusion'
        let panels = [];

        // Command history for undo/redo
        const commandHistory = {
            undoStack: [],
            redoStack: [],
            maxSize: 50
        };

        // Canvas zoom and pan state
        let canvasZoom = 1;
        let isPanning = false;
        let panStartPoint = null;
        let viewportTransform = [1, 0, 0, 1, 0, 0];
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 5;

        // Edit mode state
        let editMode = false;
        let editingPolygon = null;
        let vertexCircles = [];

        class Command {
            constructor(execute, undo, description) {
                this.execute = execute;
                this.undo = undo;
                this.description = description;
            }
        }

        function executeCommand(command) {
            command.execute();
            commandHistory.undoStack.push(command);
            commandHistory.redoStack = []; // Clear redo stack on new action

            // Limit stack size
            if (commandHistory.undoStack.length > commandHistory.maxSize) {
                commandHistory.undoStack.shift();
            }

            updateUndoRedoButtons();
        }

        function undo() {
            if (commandHistory.undoStack.length === 0) return;

            const command = commandHistory.undoStack.pop();
            command.undo();
            commandHistory.redoStack.push(command);
            updateUndoRedoButtons();
        }

        function redo() {
            if (commandHistory.redoStack.length === 0) return;

            const command = commandHistory.redoStack.pop();
            command.execute();
            commandHistory.undoStack.push(command);
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (undoBtn) undoBtn.disabled = commandHistory.undoStack.length === 0;
            if (redoBtn) redoBtn.disabled = commandHistory.redoStack.length === 0;
        }

        // Zoom and pan functions
        function zoomIn() {
            if (!canvas) return;
            const newZoom = Math.min(canvasZoom * 1.2, MAX_ZOOM);
            setZoom(newZoom);
        }

        function zoomOut() {
            if (!canvas) return;
            const newZoom = Math.max(canvasZoom / 1.2, MIN_ZOOM);
            setZoom(newZoom);
        }

        function resetZoom() {
            if (!canvas) return;
            canvasZoom = 1;
            canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
            canvas.renderAll();
            updateZoomDisplay();
        }

        function setZoom(zoom, centerPoint = null) {
            if (!canvas) return;

            canvasZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));

            // If no center point provided, zoom to canvas center
            if (!centerPoint) {
                centerPoint = new fabric.Point(canvas.width / 2, canvas.height / 2);
            }

            // Apply zoom
            canvas.zoomToPoint(centerPoint, canvasZoom);
            canvas.renderAll();
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            const zoomPercentage = Math.round(canvasZoom * 100);
            document.getElementById('zoomLevel').textContent = `${zoomPercentage}%`;
        }

        // Edit mode functions
        function toggleEditMode() {
            if (!canvas) return;

            editMode = !editMode;
            const editBtn = document.getElementById('editModeBtn');

            if (editMode) {
                editBtn.classList.add('active');
                document.getElementById('drawingInstruction').textContent =
                    'Edit Mode: Click a polygon to edit its vertices. Drag the yellow circles to move points.';

                // Disable drawing modes
                drawingMode = null;
                document.getElementById('drawRoofBtn').classList.remove('active');
                document.getElementById('drawExclusionBtn').classList.remove('active');
            } else {
                editBtn.classList.remove('active');
                exitEditMode();
                document.getElementById('drawingInstruction').textContent =
                    'Click on the image to draw roof boundary points.';
            }
        }

        function enterPolygonEditMode(polygon) {
            if (!polygon || !canvas) return;

            editingPolygon = polygon;
            polygon.set({
                selectable: false,
                evented: false
            });

            // Create vertex circles for editing
            const points = polygon.points || [];
            vertexCircles = [];

            points.forEach((point, index) => {
                const circle = new fabric.Circle({
                    left: point.x + polygon.left,
                    top: point.y + polygon.top,
                    radius: 6,
                    fill: '#FFC107',
                    stroke: '#F59E0B',
                    strokeWidth: 2,
                    originX: 'center',
                    originY: 'center',
                    hasBorders: false,
                    hasControls: false,
                    selectable: true,
                    vertexIndex: index,
                    isVertexCircle: true
                });

                // Handle vertex dragging
                circle.on('moving', function() {
                    updatePolygonPoint(index, this.left, this.top);
                });

                canvas.add(circle);
                vertexCircles.push(circle);
            });

            canvas.renderAll();
        }

        function updatePolygonPoint(index, newX, newY) {
            if (!editingPolygon || !canvas) return;

            const points = editingPolygon.points;
            if (!points || !points[index]) return;

            // Update point relative to polygon position
            points[index].x = newX - editingPolygon.left;
            points[index].y = newY - editingPolygon.top;

            // Update polygon
            editingPolygon.set({
                points: points,
                dirty: true
            });

            canvas.renderAll();
        }

        function exitEditMode() {
            if (!canvas) return;

            // Remove all vertex circles
            vertexCircles.forEach(circle => canvas.remove(circle));
            vertexCircles = [];

            // Re-enable polygon selection
            if (editingPolygon) {
                editingPolygon.set({
                    selectable: true,
                    evented: true
                });
                editingPolygon = null;
            }

            canvas.renderAll();
        }

        // Keyboard shortcuts guide
        function showKeyboardShortcuts() {
            const shortcutsHTML = `
                <div class="shortcuts-category">
                    <i data-lucide="edit-3" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: middle;"></i>
                    Drawing & Editing
                </div>
                <table class="shortcuts-table">
                    <tr>
                        <td><kbd>Click</kbd></td>
                        <td>Add point to polygon (in drawing mode)</td>
                    </tr>
                    <tr>
                        <td><kbd>Ctrl</kbd> + <kbd>Z</kbd></td>
                        <td>Undo last action</td>
                    </tr>
                    <tr>
                        <td><kbd>Ctrl</kbd> + <kbd>Y</kbd></td>
                        <td>Redo action</td>
                    </tr>
                    <tr>
                        <td><kbd>Delete</kbd></td>
                        <td>Delete selected polygon</td>
                    </tr>
                    <tr>
                        <td><kbd>Esc</kbd></td>
                        <td>Clear selection / Exit edit mode</td>
                    </tr>
                </table>

                <div class="shortcuts-category">
                    <i data-lucide="move" style="width: 16px; height: 16px; margin-right: 6px; vertical-align: middle;"></i>
                    View Controls
                </div>
                <table class="shortcuts-table">
                    <tr>
                        <td><kbd>Ctrl</kbd> + <kbd>Scroll</kbd></td>
                        <td>Zoom in/out at cursor position</td>
                    </tr>
                    <tr>
                        <td><kbd>Ctrl</kbd> + <kbd>0</kbd></td>
                        <td>Reset zoom to 100%</td>
                    </tr>
                    <tr>
                        <td><kbd>Space</kbd> + <kbd>Drag</kbd></td>
                        <td>Pan canvas (move view)</td>
                    </tr>
                </table>

                <div style="background: #e8f4fd; padding: 12px; border-radius: 6px; margin-top: 15px; font-size: 13px; color: #1F2937;">
                    <strong>ðŸ’¡ Pro Tip:</strong> Use <kbd>Ctrl</kbd> + <kbd>Z</kbd> / <kbd>Ctrl</kbd> + <kbd>Y</kbd> to undo/redo any drawing mistakes.
                    All polygon operations are reversible!
                </div>
            `;

            const modal = document.getElementById('modalOverlay');
            const messageEl = document.getElementById('modalMessage');
            const titleEl = document.getElementById('modalTitle');
            const iconEl = document.getElementById('modalIcon');
            const okBtn = document.getElementById('modalOkBtn');
            const cancelBtn = document.getElementById('modalCancelBtn');

            messageEl.innerHTML = shortcutsHTML;
            titleEl.textContent = 'Keyboard Shortcuts';
            iconEl.setAttribute('data-lucide', 'keyboard');
            iconEl.style.color = '#3B82F6';

            cancelBtn.style.display = 'none';
            okBtn.textContent = 'Got it!';
            okBtn.onclick = closeModal;

            modal.classList.add('active');
            lucide.createIcons();

            document.addEventListener('keydown', handleModalEscape);
        }

        // Modal system
        function showModal(message, type = 'info', title = null, onConfirm = null) {
            const modal = document.getElementById('modalOverlay');
            const messageEl = document.getElementById('modalMessage');
            const titleEl = document.getElementById('modalTitle');
            const iconEl = document.getElementById('modalIcon');
            const okBtn = document.getElementById('modalOkBtn');
            const cancelBtn = document.getElementById('modalCancelBtn');

            messageEl.textContent = message;

            // Set icon and title based on type
            const config = {
                error: { icon: 'alert-circle', title: 'Error', color: '#EF4444' },
                warning: { icon: 'alert-triangle', title: 'Warning', color: '#F59E0B' },
                success: { icon: 'check-circle', title: 'Success', color: '#10B981' },
                info: { icon: 'info', title: 'Information', color: '#3B82F6' },
                confirm: { icon: 'help-circle', title: 'Confirm', color: '#F59E0B' }
            };

            const cfg = config[type] || config.info;
            titleEl.textContent = title || cfg.title;
            iconEl.setAttribute('data-lucide', cfg.icon);
            iconEl.style.color = cfg.color;

            // Show/hide cancel button for confirmations
            if (type === 'confirm') {
                cancelBtn.style.display = 'inline-block';
                okBtn.textContent = 'Confirm';
                okBtn.onclick = () => {
                    closeModal();
                    if (onConfirm) onConfirm(true);
                };
                cancelBtn.onclick = () => {
                    closeModal();
                    if (onConfirm) onConfirm(false);
                };
            } else {
                cancelBtn.style.display = 'none';
                okBtn.textContent = 'OK';
                okBtn.onclick = closeModal;
            }

            modal.classList.add('active');
            lucide.createIcons(); // Re-render icon

            // ESC key to close
            document.addEventListener('keydown', handleModalEscape);
        }

        function closeModal() {
            const modal = document.getElementById('modalOverlay');
            modal.classList.remove('active');
            document.removeEventListener('keydown', handleModalEscape);
        }

        function handleModalEscape(e) {
            if (e.key === 'Escape') {
                closeModal();
            }
        }

        // Loading system
        function showLoading(message = 'Processing...') {
            document.getElementById('loadingMessage').textContent = message;
            document.getElementById('loadingOverlay').classList.add('active');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.remove('active');
        }

        // Step navigation
        function goToStep(step) {
            document.querySelectorAll('.step-container').forEach(el => el.classList.remove('active'));
            document.getElementById(`step${step}`).classList.add('active');
            currentStep = step;
        }

        // Upload zone setup
        const uploadZone = document.getElementById('uploadZone');
        const imageInput = document.getElementById('imageInput');

        uploadZone.addEventListener('click', () => imageInput.click());

        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragging');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragging');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragging');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                handleImageUpload(file);
            }
        });

        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleImageUpload(file);
            }
        });

        async function handleImageUpload(file) {
            uploadedImage = file;

            // Upload to server
            showLoading('Uploading image...');

            const formData = new FormData();
            formData.append('file', file);

            const customerName = document.getElementById('customerName').value;
            const customerAddress = document.getElementById('customerAddress').value;
            if (customerName) formData.append('customer_name', customerName);
            if (customerAddress) formData.append('customer_address', customerAddress);

            try {
                const response = await fetch('/api/roof-designer/upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    designId = result.design_id;
                    console.log('[UPLOAD] Design ID:', designId);
                    console.log('[UPLOAD] Image dimensions:', result.image_dimensions);

                    // Automatically proceed to drawing step
                    hideLoading();
                    proceedToDrawing();
                } else {
                    hideLoading();
                    showModal(result.error || 'Failed to upload image', 'error');
                }
            } catch (error) {
                console.error('Error:', error);
                hideLoading();
                showModal('Failed to upload image. Please try again.', 'error');
            }
        }

        function proceedToDrawing() {
            if (!designId) {
                showModal('Please upload an image first.', 'warning');
                return;
            }

            goToStep(2);

            // Initialize canvas
            setTimeout(() => {
                initializeCanvas();
            }, 100);
        }

        function initializeCanvas() {
            canvas = new fabric.Canvas('roofCanvas');

            const reader = new FileReader();
            reader.onload = (e) => {
                fabric.Image.fromURL(e.target.result, (img) => {
                    const scale = Math.min(900 / img.width, 700 / img.height);
                    img.scale(scale);
                    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
                    canvas.setDimensions({ width: img.width * scale, height: img.height * scale });
                });
            };
            reader.readAsDataURL(uploadedImage);

            // Setup canvas click handler for polygon drawing
            canvas.on('mouse:down', handleCanvasClick);
            canvas.on('mouse:move', handleCanvasMove);
            canvas.on('mouse:up', handleCanvasUp);

            // Mouse wheel zoom with Ctrl modifier
            canvas.on('mouse:wheel', function(opt) {
                const e = opt.e;

                // Only zoom if Ctrl is pressed
                if (e.ctrlKey) {
                    e.preventDefault();
                    e.stopPropagation();

                    const delta = e.deltaY;
                    let zoom = canvas.getZoom();
                    zoom *= 0.999 ** delta;

                    zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));

                    const point = new fabric.Point(e.offsetX, e.offsetY);
                    canvas.zoomToPoint(point, zoom);
                    canvasZoom = zoom;
                    updateZoomDisplay();
                }
            });

            // Canvas selection animations
            canvas.on('selection:created', function(e) {
                if (e.selected && e.selected[0]) {
                    const selectedObj = e.selected[0];

                    // If in edit mode and a polygon is selected, enter polygon edit mode
                    if (editMode && (selectedObj.isRoofPolygon || selectedObj.isExclusionZone)) {
                        canvas.discardActiveObject();
                        enterPolygonEditMode(selectedObj);
                        return;
                    }

                    selectedObj.set({
                        strokeWidth: selectedObj.isRoofPolygon ? 4 : 3,
                        shadow: '0 4px 12px rgba(0, 0, 0, 0.2)'
                    });
                    canvas.renderAll();
                }
            });

            canvas.on('selection:updated', function(e) {
                if (e.selected && e.selected[0]) {
                    const selectedObj = e.selected[0];

                    // If in edit mode and switching to a different polygon
                    if (editMode && (selectedObj.isRoofPolygon || selectedObj.isExclusionZone)) {
                        exitEditMode();
                        canvas.discardActiveObject();
                        enterPolygonEditMode(selectedObj);
                        return;
                    }

                    selectedObj.set({
                        strokeWidth: selectedObj.isRoofPolygon ? 4 : 3,
                        shadow: '0 4px 12px rgba(0, 0, 0, 0.2)'
                    });
                }
                if (e.deselected && e.deselected[0]) {
                    e.deselected[0].set({
                        strokeWidth: e.deselected[0].isRoofPolygon ? 3 : 2,
                        shadow: null
                    });
                }
                canvas.renderAll();
            });

            canvas.on('selection:cleared', function(e) {
                if (e.deselected && e.deselected[0]) {
                    e.deselected[0].set({
                        strokeWidth: e.deselected[0].isRoofPolygon ? 3 : 2,
                        shadow: null
                    });
                    canvas.renderAll();
                }
            });
        }

        function handleCanvasClick(options) {
            // Handle panning with Space key
            if (options.e.which === 1 && isPanning) {
                panStartPoint = { x: options.e.clientX, y: options.e.clientY };
                return;
            }

            // In edit mode, don't allow new points to be drawn
            if (editMode) {
                return;
            }

            if (drawingMode === 'roof') {
                const pointer = canvas.getPointer(options.e);
                roofPolygonPoints.push({ x: pointer.x, y: pointer.y });

                // Draw point
                const circle = new fabric.Circle({
                    left: pointer.x,
                    top: pointer.y,
                    radius: 5,
                    fill: '#00358A',
                    originX: 'center',
                    originY: 'center',
                    selectable: false,
                    roofMarker: true
                });
                canvas.add(circle);

                // Draw line from previous point
                if (roofPolygonPoints.length > 1) {
                    const prevPoint = roofPolygonPoints[roofPolygonPoints.length - 2];
                    const line = new fabric.Line([prevPoint.x, prevPoint.y, pointer.x, pointer.y], {
                        stroke: '#00358A',
                        strokeWidth: 2,
                        selectable: false,
                        roofMarker: true
                    });
                    canvas.add(line);
                }

                canvas.renderAll();

                document.getElementById('drawingInstruction').textContent =
                    `${roofPolygonPoints.length} points added. Click "Close Roof Polygon" when done.`;

            } else if (drawingMode === 'exclusion') {
                const pointer = canvas.getPointer(options.e);
                currentExclusionPoints.push({ x: pointer.x, y: pointer.y });

                // Draw point marker
                const circle = new fabric.Circle({
                    left: pointer.x,
                    top: pointer.y,
                    radius: 4,
                    fill: '#ff0000',
                    originX: 'center',
                    originY: 'center',
                    selectable: false,
                    exclusionMarker: true
                });
                canvas.add(circle);

                // Draw line from previous point
                if (currentExclusionPoints.length > 1) {
                    const prevPoint = currentExclusionPoints[currentExclusionPoints.length - 2];
                    const line = new fabric.Line([prevPoint.x, prevPoint.y, pointer.x, pointer.y], {
                        stroke: '#ff0000',
                        strokeWidth: 2,
                        selectable: false,
                        exclusionMarker: true
                    });
                    canvas.add(line);
                }

                canvas.renderAll();

                document.getElementById('drawingInstruction').textContent =
                    `Exclusion zone: ${currentExclusionPoints.length} points. Click "Close Exclusion" or continue adding points.`;
            }
        }

        function handleCanvasMove(options) {
            // Handle panning
            if (isPanning && panStartPoint) {
                const e = options.e;
                const vpt = canvas.viewportTransform.slice();
                vpt[4] += e.clientX - panStartPoint.x;
                vpt[5] += e.clientY - panStartPoint.y;
                canvas.setViewportTransform(vpt);
                panStartPoint = { x: e.clientX, y: e.clientY };
                canvas.renderAll();
            }
        }

        function handleCanvasUp(options) {
            // Reset panning
            if (isPanning) {
                panStartPoint = null;
            }
        }

        function startDrawingRoof() {
            drawingMode = 'roof';
            document.getElementById('drawRoofBtn').classList.add('active');
            document.getElementById('drawExclusionBtn').classList.remove('active');
            document.getElementById('drawingInstruction').textContent =
                'Click on the image to add roof boundary points.';
        }

        function startDrawingExclusion() {
            // First close any in-progress exclusion zone
            if (currentExclusionPoints.length > 0) {
                closeExclusionPolygon();
            }

            drawingMode = 'exclusion';
            currentExclusionPoints = []; // Reset for new exclusion zone
            document.getElementById('drawExclusionBtn').classList.add('active');
            document.getElementById('drawRoofBtn').classList.remove('active');
            document.getElementById('drawingInstruction').textContent =
                'Click on image to add exclusion zone points (chimney, vent, etc.). Click "Close Exclusion" when done.';
        }

        function closePolygon() {
            if (drawingMode === 'roof' || (!drawingMode && roofPolygonPoints.length >= 3)) {
                closeRoofPolygon();
            } else if (drawingMode === 'exclusion' || currentExclusionPoints.length >= 3) {
                closeExclusionPolygon();
            } else {
                showModal('Please add at least 3 points to create a polygon.', 'info');
            }
        }

        function closeRoofPolygon() {
            if (roofPolygonPoints.length < 3) {
                showModal('Please add at least 3 points to create roof polygon.', 'info');
                return;
            }

            const savedPoints = [...roofPolygonPoints];
            const tempMarkers = canvas.getObjects().filter(obj => obj.roofMarker);

            const command = new Command(
                () => {
                    // Execute: Create roof polygon
                    // Remove all temporary circles and lines for roof
                    canvas.getObjects().forEach(obj => {
                        if (obj.roofMarker) {
                            canvas.remove(obj);
                        }
                    });

                    // Create filled polygon
                    roofPolygonObject = new fabric.Polygon(savedPoints, {
                        fill: 'rgba(0, 123, 255, 0.2)',
                        stroke: '#00358A',
                        strokeWidth: 3,
                        selectable: true,
                        lockRotation: true,
                        isRoofPolygon: true
                    });
                    canvas.add(roofPolygonObject);
                    canvas.renderAll();

                    drawingMode = null;
                    document.getElementById('drawRoofBtn').classList.remove('active');
                    document.getElementById('drawingInstruction').textContent =
                        'Roof boundary complete! Add exclusion zones or proceed to panel layout.';
                },
                () => {
                    // Undo: Remove roof polygon and restore markers
                    if (roofPolygonObject) {
                        canvas.remove(roofPolygonObject);
                        roofPolygonObject = null;
                    }

                    // Restore temporary markers
                    tempMarkers.forEach(marker => canvas.add(marker));
                    canvas.renderAll();

                    drawingMode = 'roof';
                    document.getElementById('drawRoofBtn').classList.add('active');
                    document.getElementById('drawingInstruction').textContent =
                        `${roofPolygonPoints.length} points added. Click "Close Roof Polygon" when done.`;
                },
                'Close roof polygon'
            );

            executeCommand(command);
        }

        function closeExclusionPolygon() {
            if (currentExclusionPoints.length < 3) {
                showModal('Please add at least 3 points to create exclusion zone.', 'info');
                return;
            }

            const savedPoints = [...currentExclusionPoints];
            const tempMarkers = canvas.getObjects().filter(obj => obj.exclusionMarker);

            const command = new Command(
                () => {
                    // Execute: Create exclusion polygon
                    // Remove temporary markers for this exclusion zone
                    canvas.getObjects().forEach(obj => {
                        if (obj.exclusionMarker) {
                            canvas.remove(obj);
                        }
                    });

                    // Create filled exclusion polygon
                    const exclusionPoly = new fabric.Polygon(savedPoints, {
                        fill: 'rgba(255, 0, 0, 0.3)',
                        stroke: '#ff0000',
                        strokeWidth: 2,
                        selectable: true,
                        lockRotation: true,
                        isExclusionZone: true
                    });
                    canvas.add(exclusionPoly);

                    // Save to exclusion zones array
                    exclusionZones.push({
                        points: [...savedPoints],
                        polygon: exclusionPoly
                    });

                    console.log('[EXCLUSION] Added polygon zone:', savedPoints.length, 'points');

                    canvas.renderAll();

                    // Reset for next exclusion zone
                    currentExclusionPoints = [];
                    drawingMode = null;
                    document.getElementById('drawExclusionBtn').classList.remove('active');
                    document.getElementById('drawingInstruction').textContent =
                        `Exclusion zone added (${exclusionZones.length} total). Add more zones or proceed to layout.`;
                },
                () => {
                    // Undo: Remove exclusion polygon and restore markers
                    if (exclusionZones.length > 0) {
                        const lastZone = exclusionZones.pop();
                        canvas.remove(lastZone.polygon);
                    }

                    // Restore temporary markers
                    tempMarkers.forEach(marker => canvas.add(marker));
                    currentExclusionPoints = [...savedPoints];
                    canvas.renderAll();

                    drawingMode = 'exclusion';
                    document.getElementById('drawExclusionBtn').classList.add('active');
                    document.getElementById('drawingInstruction').textContent =
                        `Exclusion zone: ${savedPoints.length} points. Click "Close Exclusion" or continue adding points.`;
                },
                'Add exclusion zone'
            );

            executeCommand(command);
        }

        function deleteSelected() {
            const activeObject = canvas.getActiveObject();
            if (!activeObject) {
                showModal('No object selected. Click on a polygon first, then click Delete.', 'info');
                return;
            }

            const type = activeObject.isRoofPolygon ? 'roof boundary' :
                        activeObject.isExclusionZone ? 'exclusion zone' : 'object';

            showModal(
                `Are you sure you want to delete this ${type}? This action can be undone with Ctrl+Z.`,
                'confirm',
                'Confirm Deletion',
                (confirmed) => {
                    if (confirmed) {
                        const savedObject = activeObject;
                        let savedZoneIndex = -1;

                        // Find zone index if it's an exclusion zone
                        if (savedObject.isExclusionZone) {
                            savedZoneIndex = exclusionZones.findIndex(zone => zone.polygon === savedObject);
                        }

                        const command = new Command(
                            () => {
                                // Execute: Delete object
                                if (savedObject.isExclusionZone && savedZoneIndex !== -1) {
                                    exclusionZones.splice(savedZoneIndex, 1);
                                    console.log('[EXCLUSION] Removed zone. Remaining:', exclusionZones.length);
                                } else if (savedObject.isRoofPolygon) {
                                    roofPolygonObject = null;
                                }

                                canvas.remove(savedObject);
                                canvas.renderAll();
                            },
                            () => {
                                // Undo: Restore object
                                canvas.add(savedObject);

                                if (savedObject.isExclusionZone && savedZoneIndex !== -1) {
                                    const savedPoints = savedObject.points || [];
                                    exclusionZones.splice(savedZoneIndex, 0, {
                                        points: savedPoints,
                                        polygon: savedObject
                                    });
                                } else if (savedObject.isRoofPolygon) {
                                    roofPolygonObject = savedObject;
                                }

                                canvas.renderAll();
                            },
                            `Delete ${type}`
                        );

                        executeCommand(command);
                    }
                }
            );
        }

        function clearAll() {
            showModal(
                'This will delete all polygons and reset the canvas. This action cannot be undone. Are you sure?',
                'confirm',
                'Clear All',
                (confirmed) => {
                    if (confirmed) {
                        clearAllPolygons();
                    }
                }
            );
        }

        function clearAllPolygons() {
            canvas.clear();
            roofPolygonPoints = [];
            exclusionZones = [];
            currentExclusionPoints = [];
            roofPolygonObject = null;
            drawingMode = null;

            // Clear command history since we're starting fresh
            commandHistory.undoStack = [];
            commandHistory.redoStack = [];
            updateUndoRedoButtons();

            // Reload background image
            const reader = new FileReader();
            reader.onload = (e) => {
                fabric.Image.fromURL(e.target.result, (img) => {
                    const scale = Math.min(900 / img.width, 700 / img.height);
                    img.scale(scale);
                    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
                });
            };
            reader.readAsDataURL(uploadedImage);

            document.getElementById('drawingInstruction').textContent =
                'Click on the image to draw roof boundary points.';
        }

        function proceedToLayout() {
            if (!roofPolygonObject || roofPolygonPoints.length < 3) {
                showModal('Please draw and close the roof boundary polygon first.', 'warning');
                return;
            }

            goToStep(3);

            // Initialize layout canvas
            setTimeout(() => {
                initializeLayoutCanvas();
            }, 100);
        }

        function initializeLayoutCanvas() {
            layoutCanvas = new fabric.Canvas('layoutCanvas');

            const reader = new FileReader();
            reader.onload = (e) => {
                fabric.Image.fromURL(e.target.result, (img) => {
                    const scale = Math.min(900 / img.width, 700 / img.height);
                    img.scale(scale);
                    layoutCanvas.setBackgroundImage(img, layoutCanvas.renderAll.bind(layoutCanvas));
                    layoutCanvas.setDimensions({ width: img.width * scale, height: img.height * scale });

                    // Draw roof polygon
                    const poly = new fabric.Polygon(roofPolygonPoints, {
                        fill: 'rgba(0, 123, 255, 0.1)',
                        stroke: '#00358A',
                        strokeWidth: 2,
                        selectable: false
                    });
                    layoutCanvas.add(poly);

                    // Draw polygon exclusion zones
                    exclusionZones.forEach(zone => {
                        const exclusionPoly = new fabric.Polygon(zone.points, {
                            fill: 'rgba(255, 0, 0, 0.3)',
                            stroke: '#ff0000',
                            strokeWidth: 2,
                            selectable: false
                        });
                        layoutCanvas.add(exclusionPoly);
                    });

                    layoutCanvas.renderAll();
                });
            };
            reader.readAsDataURL(uploadedImage);
        }

        async function calculatePanelLayout() {
            if (!layoutCanvas) {
                showModal('Layout canvas not initialized. Please try again.', 'error');
                return;
            }

            const panelWidth = parseFloat(document.getElementById('panelWidth').value);
            const panelHeight = parseFloat(document.getElementById('panelHeight').value);
            const panelPower = parseInt(document.getElementById('panelPower').value);
            const orientation = document.getElementById('orientation').value;
            const spacing = parseFloat(document.getElementById('spacing').value) / 100; // Convert cm to m
            const pixelsPerMeter = parseFloat(document.getElementById('pixelsPerMeter').value);

            // Validate panel dimensions - realistic solar panel sizes
            if (panelWidth < 0.8 || panelWidth > 2.5) {
                showModal(
                    'Panel width should be between 0.8m and 2.5m. Standard solar panels are typically 1.6m - 2.0m wide. Very small panels will cause calculation timeouts.',
                    'warning',
                    'Invalid Panel Width'
                );
                return;
            }

            if (panelHeight < 0.8 || panelHeight > 2.0) {
                showModal(
                    'Panel height should be between 0.8m and 2.0m. Standard solar panels are typically 0.9m - 1.2m tall. Very small panels will cause calculation timeouts.',
                    'warning',
                    'Invalid Panel Height'
                );
                return;
            }

            // Warn about very small panels
            const panelArea = panelWidth * panelHeight;
            if (panelArea < 1.0) {
                showModal(
                    `Panel area is ${panelArea.toFixed(2)}mÂ² which is very small. Standard panels are 1.5-2.0mÂ². This may cause slow calculations or timeouts. Continue?`,
                    'confirm',
                    'Small Panel Size Warning',
                    (confirmed) => {
                        if (confirmed) {
                            proceedWithCalculation();
                        }
                    }
                );
                return;
            }

            proceedWithCalculation();

            async function proceedWithCalculation() {
                showLoading('Calculating optimal panel layout...');

                // Prepare obstacle data - send only points, not fabric objects
                const obstacleData = exclusionZones.map(zone => ({
                    points: zone.points
                }));

                const formData = new FormData();
                formData.append('design_id', designId);
                formData.append('roof_polygon', JSON.stringify(roofPolygonPoints));
                formData.append('obstacles', JSON.stringify(obstacleData));
                formData.append('panel_width_m', panelWidth);
                formData.append('panel_height_m', panelHeight);
                formData.append('panel_power_w', panelPower);
                formData.append('spacing_m', spacing);
                formData.append('pixels_per_meter', pixelsPerMeter);
                formData.append('orientation', orientation);

                try {
                    // Add timeout to prevent hanging
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 second timeout

                    const response = await fetch('/api/roof-designer/calculate-layout', {
                        method: 'POST',
                        body: formData,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`Server error: ${response.status}`);
                    }

                    const result = await response.json();

                    if (result.success) {
                        console.log('[CALC] Calculation successful. Panels:', result.total_panels);
                        panels = result.panels;
                        displayPanels();
                        displayResults(result);
                        document.getElementById('saveBtn').disabled = result.total_panels === 0;

                        // Show success message
                        if (result.total_panels > 0) {
                            showModal(`Successfully placed ${result.total_panels} panels!`, 'success');
                        } else {
                            showModal('No panels could be placed. Try adjusting panel size or roof area.', 'warning');
                        }
                    } else {
                        console.error('[CALC] Calculation failed:', result.error);
                        showModal(result.error || 'Failed to calculate layout', 'error');
                    }
                } catch (error) {
                    console.error('[CALC] Error:', error);
                    if (error.name === 'AbortError') {
                        showModal('Calculation timed out. The roof area might be too complex. Please try with a simpler design.', 'error');
                    } else {
                        showModal('Failed to calculate layout. Please check your internet connection and try again.', 'error');
                    }
                } finally {
                    hideLoading();
                }
            }
        }

        function displayPanels() {
            // Clear existing panels
            layoutCanvas.getObjects().forEach(obj => {
                if (obj.panelRect) {
                    layoutCanvas.remove(obj);
                }
            });

            console.log(`[DISPLAY] Rendering ${panels.length} panels...`);

            // Draw panels with photo-realistic solar panel appearance
            panels.forEach((panel, idx) => {
                const elements = [];

                // 1. Drop shadow for 3D effect
                const shadow = new fabric.Rect({
                    left: 2,
                    top: 2,
                    width: panel.width,
                    height: panel.height,
                    fill: 'rgba(0, 0, 0, 0.3)',
                    selectable: false
                });
                elements.push(shadow);

                // 2. Aluminum frame (silver border)
                const frame = new fabric.Rect({
                    left: 0,
                    top: 0,
                    width: panel.width,
                    height: panel.height,
                    fill: '#bfc5d0', // Aluminum silver
                    stroke: '#8b95a3',
                    strokeWidth: 1,
                    selectable: false
                });
                elements.push(frame);

                // 3. Glass surface (dark blue-black with slight gradient effect)
                const glass = new fabric.Rect({
                    left: 3,
                    top: 3,
                    width: panel.width - 6,
                    height: panel.height - 6,
                    fill: '#0a1628', // Very dark blue-black (photovoltaic color)
                    selectable: false
                });
                elements.push(glass);

                // 4. Solar cells grid - 6x10 typical configuration
                const cellRows = 6;
                const cellCols = 10;
                const cellGap = 2; // Gap between cells
                const cellWidth = (panel.width - 6 - (cellCols + 1) * cellGap) / cellCols;
                const cellHeight = (panel.height - 6 - (cellRows + 1) * cellGap) / cellRows;

                // Draw individual solar cells with subtle blue tint
                for (let row = 0; row < cellRows; row++) {
                    for (let col = 0; col < cellCols; col++) {
                        const cellX = 3 + cellGap + col * (cellWidth + cellGap);
                        const cellY = 3 + cellGap + row * (cellHeight + cellGap);

                        // Individual cell with darker blue
                        const cell = new fabric.Rect({
                            left: cellX,
                            top: cellY,
                            width: cellWidth,
                            height: cellHeight,
                            fill: '#1a2942', // Dark blue for cells
                            stroke: '#0d1421',
                            strokeWidth: 0.3,
                            selectable: false
                        });
                        elements.push(cell);

                        // Add subtle highlight to cells for realism
                        const highlight = new fabric.Rect({
                            left: cellX,
                            top: cellY,
                            width: cellWidth,
                            height: cellHeight * 0.3,
                            fill: 'rgba(255, 255, 255, 0.03)',
                            selectable: false
                        });
                        elements.push(highlight);
                    }
                }

                // 5. Add busbars (thin silver lines connecting cells)
                const busbarColor = '#4a5568';
                for (let row = 0; row < cellRows; row++) {
                    const y = 3 + cellGap + row * (cellHeight + cellGap) + cellHeight / 2;
                    const busbar = new fabric.Line([3, y, panel.width - 3, y], {
                        stroke: busbarColor,
                        strokeWidth: 0.5,
                        selectable: false,
                        opacity: 0.4
                    });
                    elements.push(busbar);
                }

                // 6. Glass reflection effect (top-left corner)
                const reflection = new fabric.Rect({
                    left: 3,
                    top: 3,
                    width: panel.width * 0.3,
                    height: panel.height * 0.2,
                    fill: 'rgba(255, 255, 255, 0.08)',
                    selectable: false
                });
                elements.push(reflection);

                // Group all elements
                const panelGroup = new fabric.Group(elements, {
                    left: panel.x,
                    top: panel.y,
                    selectable: false,
                    panelRect: true,
                    hoverCursor: 'default'
                });

                layoutCanvas.add(panelGroup);
            });

            layoutCanvas.renderAll();
            console.log(`[DISPLAY] Rendered ${panels.length} photo-realistic panels`);
        }

        function displayResults(result) {
            document.getElementById('resultPanels').textContent = result.total_panels;
            document.getElementById('resultPower').textContent = result.total_power_kw.toFixed(2) + ' kW';
            document.getElementById('resultCoverage').textContent = result.coverage_percent.toFixed(1) + '%';
            document.getElementById('layoutResults').style.display = 'block';
        }

        async function saveDesign() {
            if (!designId || panels.length === 0) {
                showModal('Please calculate panel layout first.', 'warning');
                return;
            }

            goToStep(4);

            // Copy results to final summary
            document.getElementById('finalPanels').textContent = document.getElementById('resultPanels').textContent;
            document.getElementById('finalPower').textContent = document.getElementById('resultPower').textContent;
            document.getElementById('finalCoverage').textContent = document.getElementById('resultCoverage').textContent;

            const roofArea = parseFloat(document.getElementById('resultPanels').textContent) *
                           parseFloat(document.getElementById('panelWidth').value) *
                           parseFloat(document.getElementById('panelHeight').value);
            document.getElementById('finalArea').textContent = roofArea.toFixed(2) + ' mÂ²';

            console.log('[SAVE] Design saved successfully');
        }

        function startNewDesign() {
            window.location.reload();
        }

        // Initialize
        startDrawingRoof();

        // Initialize Lucide icons
        lucide.createIcons();

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+Z / Cmd+Z - Undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }

            // Ctrl+Y / Cmd+Y / Ctrl+Shift+Z - Redo
            if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
            }

            // Ctrl+0 - Reset zoom
            if ((e.ctrlKey || e.metaKey) && e.key === '0') {
                e.preventDefault();
                resetZoom();
            }

            // Space key - Enable panning mode
            if (e.key === ' ' && !isPanning && canvas) {
                e.preventDefault();
                isPanning = true;
                canvas.defaultCursor = 'grab';
                canvas.hoverCursor = 'grab';
                canvas.renderAll();
            }

            // Delete key - Delete selected
            if (e.key === 'Delete') {
                const activeObject = canvas?.getActiveObject();
                if (activeObject) {
                    deleteSelected();
                }
            }

            // Escape - Clear selection / cancel drawing / exit edit mode
            if (e.key === 'Escape') {
                if (canvas) {
                    canvas.discardActiveObject();
                    canvas.renderAll();
                }
                if (editMode) {
                    toggleEditMode();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            // Space key released - Disable panning mode
            if (e.key === ' ' && isPanning && canvas) {
                isPanning = false;
                panStartPoint = null;
                canvas.defaultCursor = 'default';
                canvas.hoverCursor = 'move';
                canvas.renderAll();
            }
        });
    </script>
</body>
</html>
